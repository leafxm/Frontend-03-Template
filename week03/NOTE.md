# 学习笔记

## HTML解析
简化处理：逐段返回repsonse.body并处理改为全部返回完成后处理

### 第一步：文件拆分
老师总结
- parser拆分到单独文件中（便于文件管理）
- 设计parser格式：参数HTML文本，返回DOM树

### 第二步：FSM实现HTML的分析
状态机解析HTML
HTML语法：[标准](https://html.spec.whatwg.org/multipage/#toc-syntax)已经设计好状态机

老师总结
- FSM实现HTML的分析
- HTML标准中，已经规定了HTML的状态
- 只选取一部分状态，完成一个最简版本

### 第三步：解析标签
老师总结：
- 主要标签有：开始标签、结束标签、自封闭标签
- 暂时忽略属性

个人总结：
在这一步算是真正进去到解析的步骤了，主要思路和上周利用状态机解析http的文本很相似——根据规则判断每个字符之后应该字符应该处于的状态。
规则也是我们熟悉的html规则，标签的开始、类型、结束的判断。
值得一提的是，这里使用了一个`Symbol`来表示结束。

### 第四步：创建元素
老师总结：
- 在状态机中，除了状态迁移，还要加入业务逻辑
- 标签结束状态提交标签token

个人总结：
currentToken记录标签

### 第五步：处理属性
老师总结：
- 属性值分为单引号、双引号、无引号三种写法，因此需要多状态处理
- 处理属性的方式和标签类似 `currentAttribute` 暂存
- 属性结束事，把属性加到标签Token上

### 第六步：用token构建DOM树
老师总结：
- 从标签构建DOM树的基本技巧是使用栈
- 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
- 自封闭节点可以视作入栈后立刻出栈
- 任何元素的父元素是它入栈前的栈顶

个人总结：
这节课完善了`emit`函数，通过使用数组形式的`stack`的方式来完成DOM书的构建。通过每一个token触发emit的顺序和开始、结束标签的出现顺序可以判断其在DOM树中的位置。

### 第七步：将文本节点加到DOM树
老师总结：
- 文本节点和自封闭标签的处理类似
- 多个文本节点需要合并

## CSS计算
CSS Computing：把CSS规则里包含的属性应用到匹配这些元素的选择器上
### 第一步：收集CSS规则
老师总结：
- 遇到style标签时，保存CSS规则
- 调用CSS Parser来分析CSS规则
- 必须要仔细研究此库分析CSS规则的格式

个人总结：
CSS Parser库分析CSS规则的格式(重要部分)：
```
{
    stylesheet: {
        rules: [
            {
                declarations: [
                    {
                        property: '',
                        value: ''
                    }
                ]
            }
        ]
    }
}
```
### 第二步：添加调用
老师总结：
- 创建一个元素后，立即计算CSS
- 理论上，分析一个元素时，所有CSS规则已经收集完毕（一个假设）
- 真实浏览器中，会遇到写在body的style标签，需要重新CSS计算的情况，这里我们忽略

### 第三步：获取父元素序列
老师总结：
- computeCSS 函数中，必须知道元素的所有父元素才能判断元素与规则是否匹配
- 从上一个步骤的stack里，可以获取本元素所有父元素
- 因为首先获取的是“当前元素”， 所以我们获得和计算父元素匹配的顺序是从内向外

### 第四步：选择器和元素的匹配
老师总结：
- 选择器也要从当前元素向外排
- 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

### 第五步：计算选择器与元素匹配
老师总结：
- 根据选择器类型和元素属性，计算是否与当前元素匹配
- 这里只实现了三种基本选择器（id class tagName）, 实际浏览器要处理复合选择器

### 第六步：生成computed属性
老师总结：
- 一旦选择匹配，就应用到元素上，行程computedStyle

### 第七步：specificity的计算逻辑
[0,       0,      0,       0]
inline    id      class    tag
不进位制
老师总结：
- CSS规则根据specificity和后来优先规则覆盖
- specificity是四元组，越左权重越高
- 一个CSS规则的specificity根据包含的简单选择器相加而成


## 总结
这周完成了HTML解析和CSS计算的学习。
HTML解析所用的方法也算是上周学习的一个延续——使用状态机去解析标签，并在状态迁移中创建元素，把属性也添加到元素中，处理文本节点，最终构建了DOM树。
CSS计算使用CSS Parser库简化了CSS规则的收集，根据规则判断是否匹配，相同的属性根据优先级判断是否需要更新，最终实现CSS规则和DOM树的结合。
通过这周的学习，原来只是了解的规则，印象更加深刻。浏览器的实现，是有一定复杂度，复杂主要是在要对很多不同的情况去做处理，但是核心思路的实现其实也没有那么难。


